var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import lcm from 'lcm';
import _ from 'lodash';
import { ConversionError, ImpossibleSchemaError, InvalidSchemaError } from './convertOpenApi.js';
import { typeList, } from './types/endpoint.js';
export var convertSchema = function (path, schema, required) {
    if (schema === undefined) {
        throw new InvalidSchemaError(path, 'schema undefined');
    }
    // TODO(ronan): remove when fully migrated to endpoint type, or don't modify schema in evaluateCompositionsRecursive
    schema = _.cloneDeep(schema);
    schema = evaluateCompositionsRecursive(path, schema);
    return convertSchemaRecursive(path, schema, required);
};
/**
 * This function should be used to reduce strictly `oneOf` and `anyOf` compositions.
 *
 * @param schemaArray `schema.allOf` or `schema.oneOf`
 * @returns a schema array equivalent to the `schemaArray` argument, but in reduced form
 */
var evaluateOptionsCompositions = function (path, schemaArray) {
    var evaluatedArray = schemaArray.flatMap(function (subschema, i) {
        var _a;
        try {
            return (_a = evaluateCompositionsRecursive(__spreadArray(__spreadArray([], path, true), [i.toString()], false), subschema).oneOf) !== null && _a !== void 0 ? _a : [];
        }
        catch (error) {
            if (error instanceof ImpossibleSchemaError) {
                return [];
            }
            else {
                throw error;
            }
        }
    });
    if (evaluatedArray.length === 0) {
        throw new ImpossibleSchemaError(path, 'no valid options in schema:', JSON.stringify(schemaArray, undefined, 2));
    }
    return evaluatedArray;
};
var evaluateCompositionsRecursive = function (path, schema) {
    // evaluate compositions first; we are currently ignoring `not`
    if (schema.oneOf && schema.oneOf.length > 0) {
        schema.oneOf = evaluateOptionsCompositions(__spreadArray(__spreadArray([], path, true), ['oneOf'], false), schema.oneOf);
    }
    else {
        schema.oneOf = [];
    }
    if (schema.anyOf && schema.anyOf.length > 0) {
        schema.anyOf = evaluateOptionsCompositions(__spreadArray(__spreadArray([], path, true), ['anyOf'], false), schema.anyOf);
    }
    if (schema.allOf && schema.allOf.length > 0) {
        var totalAllOfObj = schema.allOf
            .map(function (subschema, i) {
            return evaluateCompositionsRecursive(__spreadArray(__spreadArray([], path, true), ['allOf', i.toString()], false), subschema);
        })
            .reduce(function (schema1, schema2, i) {
            return combineReducedSchemas(__spreadArray(__spreadArray([], path, true), ['allOf', i.toString()], false), schema1, schema2);
        }, {
            oneOf: [],
        });
        schema.oneOf = multiplySchemaArrays(path, schema.oneOf, totalAllOfObj.oneOf);
    }
    // evaluate subschemas, if present
    if (schema.properties) {
        for (var key in schema.properties) {
            schema.properties[key] = evaluateCompositionsRecursive(__spreadArray(__spreadArray([], path, true), ['properties', key], false), schema.properties[key]);
        }
    }
    if (schema.items) {
        schema.items = evaluateCompositionsRecursive(__spreadArray(__spreadArray([], path, true), ['items'], false), schema.items);
    }
    if (schema.additionalProperties && typeof schema.additionalProperties === 'object') {
        try {
            schema.additionalProperties = evaluateCompositionsRecursive(__spreadArray(__spreadArray([], path, true), ['additionalProperties'], false), schema.additionalProperties);
        }
        catch (error) {
            if (error instanceof ImpossibleSchemaError) {
                // if additionalProperties schema is impossible, rather than error, just disallow additionalProperties
                schema.additionalProperties = false;
            }
            else {
                throw error;
            }
        }
    }
    if (schema.anyOf && schema.anyOf.length > 0) {
        schema.oneOf = multiplySchemaArrays(path, schema.oneOf, schema.anyOf);
    }
    var topLevelSchemaArray = generateTopLevelSchemaArray(schema);
    return { oneOf: multiplySchemaArrays(path, schema.oneOf, topLevelSchemaArray) };
};
var generateTopLevelSchemaArray = function (schema) {
    if (schema.nullable) {
        var typedSchema = __assign({}, schema);
        delete typedSchema.oneOf;
        delete typedSchema.nullable;
        var nullSchema = __assign({}, schema);
        delete nullSchema.oneOf;
        delete nullSchema.nullable;
        nullSchema.type = 'null';
        return [typedSchema, nullSchema];
    }
    if (Array.isArray(schema.type)) {
        if (schema.type.length === 0) {
            var topLevelSchema_1 = __assign({}, schema);
            delete topLevelSchema_1.oneOf;
            delete topLevelSchema_1.type;
            return [topLevelSchema_1];
        }
        return schema.type.map(function (typeString) {
            var topLevelSchema = __assign({}, schema);
            delete topLevelSchema.oneOf;
            topLevelSchema.type = typeString;
            return topLevelSchema;
        });
    }
    var topLevelSchema = __assign({}, schema);
    delete topLevelSchema.oneOf;
    return [topLevelSchema];
};
/**
 * Given two arrays representing schema options, return an array representing schema options that satisfy one element in both arrays.
 *
 * It is helpful to think of each array as a union of all the schemas in the array. This function can then be thought of as taking
 * the intersection of the two union types.
 *
 * @param a first array of schema options
 * @param b second array of schema options
 * @returns array of schemas that satisfy both arrays
 */
var multiplySchemaArrays = function (path, a, b) {
    if (a.length === 0 && b.length === 0) {
        return [{}];
    }
    if (a.length === 0) {
        return b;
    }
    if (b.length === 0) {
        return a;
    }
    var product = a.flatMap(function (schema1) {
        return b.flatMap(function (schema2) {
            try {
                var combinedSchema = combineTopLevelSchemas(path, schema1, schema2);
                return [combinedSchema];
            }
            catch (error) {
                if (error instanceof ImpossibleSchemaError) {
                    return [];
                }
                else {
                    throw error;
                }
            }
        });
    });
    if (product.length === 0) {
        throw new ImpossibleSchemaError(path, 'impossible schema combination:', 'schema array 1:', JSON.stringify(a, undefined, 2), 'schema array 2:', JSON.stringify(b, undefined, 2));
    }
    return product;
};
var combineReducedSchemas = function (path, schema1, schema2) {
    var _a, _b;
    return {
        oneOf: multiplySchemaArrays(path, ((_a = schema1.oneOf) !== null && _a !== void 0 ? _a : []), ((_b = schema2.oneOf) !== null && _b !== void 0 ? _b : [])),
    };
};
export var combineTopLevelSchemas = function (path, schema1, schema2) {
    var _a, _b;
    var type1 = schema1.type;
    var type2 = schema2.type;
    // don't throw an error if number type is being constricted
    if (type1 === 'integer' && type2 === 'number') {
        type2 = 'integer';
    }
    else if (type1 === 'number' && type2 === 'integer') {
        type1 = 'integer';
    }
    if (type1 && type2 && type1 !== type2) {
        throw new ImpossibleSchemaError(path, "mismatched type in composition: \"".concat(type1, "\" \"").concat(type2, "\""));
    }
    for (var _i = 0, _c = [schema1, schema2]; _i < _c.length; _i++) {
        var schema = _c[_i];
        if (typeof schema.exclusiveMaximum === 'number') {
            if (schema.maximum === undefined || schema.maximum >= schema.exclusiveMaximum) {
                schema.maximum = schema.exclusiveMaximum;
                schema.exclusiveMaximum = true;
            }
            else {
                schema.exclusiveMaximum = undefined;
            }
        }
        if (typeof schema.exclusiveMinimum === 'number') {
            if (schema.minimum === undefined || schema.minimum <= schema.exclusiveMinimum) {
                schema.minimum = schema.exclusiveMinimum;
                schema.exclusiveMinimum = true;
            }
            else {
                schema.exclusiveMinimum = undefined;
            }
        }
    }
    var combinedSchema = {
        title: takeLast(schema1, schema2, 'title'),
        description: takeLast(schema1, schema2, 'description'),
        format: takeLast(schema1, schema2, 'format'),
        multipleOf: combine(schema1, schema2, 'multipleOf', lcm),
        maximum: combine(schema1, schema2, 'maximum', Math.min),
        minimum: combine(schema1, schema2, 'minimum', Math.max),
        maxLength: combine(schema1, schema2, 'maxLength', Math.min),
        minLength: combine(schema1, schema2, 'minLength', Math.max),
        maxItems: combine(schema1, schema2, 'maxItems', Math.min),
        minItems: combine(schema1, schema2, 'minItems', Math.max),
        maxProperties: combine(schema1, schema2, 'maxProperties', Math.min),
        minProperties: combine(schema1, schema2, 'minProperties', Math.max),
        required: combine(schema1, schema2, 'required', function (a, b) {
            return b.concat(a.filter(function (value) { return !b.includes(value); }));
        }),
        enum: combine(schema1, schema2, 'enum', function (a, b) { return b.filter(function (value) { return a.includes(value); }); }),
        readOnly: schema1.readOnly && schema2.readOnly,
        writeOnly: schema1.writeOnly && schema2.writeOnly,
        deprecated: schema1.deprecated && schema2.deprecated,
    };
    combinedSchema.exclusiveMaximum =
        (schema1.maximum === combinedSchema.maximum ? schema1.exclusiveMaximum : undefined) ||
            (schema2.maximum === combinedSchema.maximum ? schema2.exclusiveMaximum : undefined);
    combinedSchema.exclusiveMinimum =
        (schema1.minimum === combinedSchema.minimum ? schema1.exclusiveMinimum : undefined) ||
            (schema2.minimum === combinedSchema.minimum ? schema2.exclusiveMinimum : undefined);
    if (typeof schema1.example === 'object' &&
        typeof schema2.example === 'object' &&
        (schema1.example != null || schema2.example != null)) {
        combinedSchema.example = __assign(__assign({}, schema1.example), schema2.example);
    }
    else {
        combinedSchema.example = takeLast(schema1, schema2, 'example');
    }
    var type = type1 !== null && type1 !== void 0 ? type1 : type2;
    if (type === 'array') {
        return __assign({ type: type, items: combineReducedSchemas(__spreadArray(__spreadArray([], path, true), ['items'], false), (_a = schema1.items) !== null && _a !== void 0 ? _a : {}, (_b = schema2.items) !== null && _b !== void 0 ? _b : {}) }, combinedSchema);
    }
    if (schema1.properties && schema2.properties) {
        var combinedProperties_1 = __assign({}, schema1.properties);
        Object.entries(schema2.properties).forEach(function (_a) {
            var property = _a[0], schema = _a[1];
            if (property in combinedProperties_1) {
                combinedProperties_1[property] = combineReducedSchemas(__spreadArray(__spreadArray([], path, true), ['properties', property], false), combinedProperties_1[property], schema);
            }
            else {
                combinedProperties_1[property] = schema;
            }
        });
        combinedSchema.properties = combinedProperties_1;
    }
    else if (schema1.properties || schema2.properties) {
        combinedSchema.properties = __assign(__assign({}, schema1.properties), schema2.properties);
    }
    if (schema1.additionalProperties === false || schema2.additionalProperties === false) {
        combinedSchema.additionalProperties = false;
    }
    else if (schema1.additionalProperties &&
        typeof schema1.additionalProperties === 'object' &&
        schema2.additionalProperties &&
        typeof schema2.additionalProperties === 'object') {
        combinedSchema.additionalProperties = combineReducedSchemas(__spreadArray(__spreadArray([], path, true), ['additionalProperties'], false), schema1.additionalProperties, schema2.additionalProperties);
    }
    else if (schema1.additionalProperties && typeof schema1.additionalProperties === 'object') {
        combinedSchema.additionalProperties = schema1.additionalProperties;
    }
    else if (schema2.additionalProperties && typeof schema2.additionalProperties === 'object') {
        combinedSchema.additionalProperties = schema2.additionalProperties;
    }
    return __assign({ type: type }, combinedSchema);
};
export var addKeyIfDefined = function (key, value, destination) {
    if (value !== undefined) {
        destination[key] = value;
    }
};
export var copyKeyIfDefined = function (key, source, destination) {
    if (source[key] !== undefined) {
        destination[key] = source[key];
    }
};
var takeLast = function (schema1, schema2, key) {
    var _a;
    return (_a = schema2[key]) !== null && _a !== void 0 ? _a : schema1[key];
};
var combine = function (schema1, schema2, key, transform) {
    var _a;
    return schema1[key] !== undefined && schema2[key] !== undefined
        ? transform(schema1[key], schema2[key])
        : (_a = schema1[key]) !== null && _a !== void 0 ? _a : schema2[key];
};
var convertSchemaRecursive = function (path, schema, required) {
    if (schema.oneOf === undefined || schema.oneOf.length === 0) {
        throw new ConversionError(path, 'missing schema definition');
    }
    var schemaArray = schema.oneOf.map(function (schema) {
        var sharedProps = {};
        addKeyIfDefined('required', required, sharedProps);
        copyKeyIfDefined('title', schema, sharedProps);
        copyKeyIfDefined('description', schema, sharedProps);
        copyKeyIfDefined('readOnly', schema, sharedProps);
        copyKeyIfDefined('writeOnly', schema, sharedProps);
        copyKeyIfDefined('deprecated', schema, sharedProps);
        if (schema.type === undefined) {
            var inferredType = inferType(schema);
            if (inferredType === undefined) {
                return __assign({ type: 'any' }, sharedProps);
            }
            schema.type = inferredType;
        }
        var type = schema.type;
        if (!typeList.includes(type)) {
            throw new InvalidSchemaError(path, "invalid schema type: ".concat(schema.type));
        }
        switch (schema.type) {
            case 'boolean':
                var booleanProps = sharedProps;
                copyKeyIfDefined('default', schema, booleanProps);
                copyKeyIfDefined('example', schema, booleanProps);
                return __assign({ type: schema.type }, booleanProps);
            case 'number':
            case 'integer':
                if (schema.enum) {
                    var numberEnumProps = sharedProps;
                    copyKeyIfDefined('default', schema, numberEnumProps);
                    copyKeyIfDefined('example', schema, numberEnumProps);
                    return __assign({ type: schema.type === 'number' ? 'numberEnum' : 'integerEnum', enum: schema.enum }, numberEnumProps);
                }
                var numberProps = sharedProps;
                copyKeyIfDefined('multipleOf', schema, numberProps);
                copyKeyIfDefined('maximum', schema, numberProps);
                copyKeyIfDefined('exclusiveMaximum', schema, numberProps);
                copyKeyIfDefined('minimum', schema, numberProps);
                copyKeyIfDefined('exclusiveMinimum', schema, numberProps);
                copyKeyIfDefined('default', schema, numberProps);
                copyKeyIfDefined('example', schema, numberProps);
                return __assign({ type: schema.type }, numberProps);
            case 'string':
                if (schema.enum) {
                    var stringEnumProps = sharedProps;
                    copyKeyIfDefined('default', schema, stringEnumProps);
                    copyKeyIfDefined('example', schema, stringEnumProps);
                    return __assign({ type: 'stringEnum', enum: schema.enum }, stringEnumProps);
                }
                var stringProps = sharedProps;
                copyKeyIfDefined('format', schema, stringProps);
                copyKeyIfDefined('pattern', schema, stringProps);
                copyKeyIfDefined('maxLength', schema, stringProps);
                copyKeyIfDefined('minLength', schema, stringProps);
                copyKeyIfDefined('default', schema, stringProps);
                copyKeyIfDefined('example', schema, stringProps);
                return __assign({ type: schema.type }, stringProps);
            case 'array':
                var arrayProps = sharedProps;
                copyKeyIfDefined('maxItems', schema, arrayProps);
                copyKeyIfDefined('minItems', schema, arrayProps);
                copyKeyIfDefined('uniqueItems', schema, arrayProps);
                copyKeyIfDefined('default', schema, arrayProps);
                copyKeyIfDefined('example', schema, arrayProps);
                return __assign({ type: schema.type, items: convertSchemaRecursive(__spreadArray(__spreadArray([], path, true), ['items'], false), schema.items) }, arrayProps);
            case 'object':
                var properties = convertProperties(__spreadArray(__spreadArray([], path, true), ['properties'], false), schema.properties, schema.required);
                var additionalProperties = typeof schema.additionalProperties === 'object' && schema.additionalProperties != null
                    ? convertSchemaRecursive(__spreadArray(__spreadArray([], path, true), ['additionalProperties'], false), schema.additionalProperties)
                    : schema.additionalProperties;
                var objectProperties = sharedProps;
                addKeyIfDefined('additionalProperties', additionalProperties, objectProperties);
                copyKeyIfDefined('maxProperties', schema, objectProperties);
                copyKeyIfDefined('minProperties', schema, objectProperties);
                copyKeyIfDefined('default', schema, objectProperties);
                copyKeyIfDefined('example', schema, objectProperties);
                return __assign({ type: schema.type, properties: properties }, objectProperties);
            case 'null':
                var nullProps = sharedProps;
                copyKeyIfDefined('default', schema, nullProps);
                copyKeyIfDefined('example', schema, nullProps);
                return __assign({ type: schema.type }, nullProps);
            default:
                throw new ImpossibleSchemaError(path, "impossible type reached: ".concat(schema.type));
        }
    });
    // must unpack first element to satisfy type
    return __spreadArray([schemaArray[0]], schemaArray.slice(1), true);
};
export var convertProperties = function (path, properties, required) {
    if (properties === undefined) {
        return {};
    }
    var newEntries = Object.entries(properties).map(function (_a) {
        var name = _a[0], schema = _a[1];
        return [
            name,
            convertSchemaRecursive(__spreadArray(__spreadArray([], path, true), [name], false), schema, (required === null || required === void 0 ? void 0 : required.includes(name)) ? true : undefined),
        ];
    });
    return Object.fromEntries(newEntries);
};
/**
 * Given an OpenAPI 3.1 schema, this function will attempt to determine the schema type
 * based on the properties present in the schema. This is useful for assigning types to
 * schemas that are missing a type.
 *
 * For example, if a schema has no type but has `schema.properties`, we can infer the
 * intended type is `object`.
 *
 * @param schema
 * @returns if exactly one type can be inferred, the string corresponding to that type; otherwise `undefined`
 */
var inferType = function (schema) {
    var _a, _b;
    var type = undefined;
    if (schema.format !== undefined ||
        schema.pattern !== undefined ||
        schema.minLength !== undefined ||
        schema.maxLength !== undefined ||
        ((_a = schema.enum) === null || _a === void 0 ? void 0 : _a.every(function (option) { return typeof option === 'string'; }))) {
        if (type !== undefined) {
            return undefined;
        }
        type = 'string';
    }
    if (schema.multipleOf !== undefined ||
        schema.minimum !== undefined ||
        schema.maximum !== undefined ||
        schema.exclusiveMinimum !== undefined ||
        schema.exclusiveMaximum !== undefined ||
        ((_b = schema.enum) === null || _b === void 0 ? void 0 : _b.every(function (option) { return typeof option === 'number'; }))) {
        if (type !== undefined) {
            return undefined;
        }
        type = 'number'; // less specific than 'integer'
    }
    if (schema.items !== undefined ||
        schema.minItems !== undefined ||
        schema.maxItems !== undefined ||
        schema.uniqueItems !== undefined) {
        if (type !== undefined) {
            return undefined;
        }
        type = 'array';
    }
    if (schema.additionalProperties !== undefined ||
        schema.properties !== undefined ||
        schema.minProperties !== undefined ||
        schema.maxProperties !== undefined) {
        if (type !== undefined) {
            return undefined;
        }
        type = 'object';
    }
    return type;
};

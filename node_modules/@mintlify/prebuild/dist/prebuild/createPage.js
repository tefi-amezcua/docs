import matter from 'gray-matter';
import isAbsoluteUrl from 'is-absolute-url';
import { remark } from 'remark';
import remarkFrontmatter from 'remark-frontmatter';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import remarkMdx from 'remark-mdx';
import { visit } from 'unist-util-visit';
import { slugToTitle, optionallyAddLeadingSlash } from '../generate.js';
export const createPage = async (pagePath, pageContent, contentDirectoryPath, openApiFiles) => {
    const { data: metadata } = matter(pageContent);
    try {
        pageContent = await preParseMdx(pageContent, contentDirectoryPath);
    }
    catch (error) {
        pageContent = `ðŸš§ A parsing error occured. Please contact the owner of this website.`;
    }
    // Replace .mdx so we can pass file paths into this function
    const slug = pagePath.replace(/\.mdx?$/, '');
    let defaultTitle = slugToTitle(slug);
    let description;
    // Append data from OpenAPI if it exists
    if (metadata === null || metadata === void 0 ? void 0 : metadata.openapi) {
        const { title, description: openApiDescription } = getOpenApiTitleAndDescription(openApiFiles, metadata === null || metadata === void 0 ? void 0 : metadata.openapi);
        if (title) {
            defaultTitle = title;
        }
        if (openApiDescription) {
            description = openApiDescription;
        }
    }
    const pageMetadata = Object.assign(Object.assign({ title: defaultTitle, description }, metadata), { href: optionallyAddLeadingSlash(slug) });
    return {
        pageMetadata,
        pageContent,
        slug: removeLeadingSlash(slug),
    };
};
export const getPageMetadataAndSlug = (pagePath, pageContent, openApiFiles) => {
    const { data: metadata } = matter(pageContent);
    // Replace .mdx, so we can pass file paths into this function
    const slug = pagePath.replace(/\.mdx?$/, '');
    let defaultTitle = slugToTitle(slug);
    // Append data from OpenAPI if it exists
    const { title, description } = getOpenApiTitleAndDescription(openApiFiles, metadata === null || metadata === void 0 ? void 0 : metadata.openapi);
    if (title) {
        defaultTitle = title;
    }
    const pageMetadata = Object.assign(Object.assign({ title: defaultTitle, description }, metadata), { href: optionallyAddLeadingSlash(slug) });
    return {
        pageMetadata,
        slug: removeLeadingSlash(slug),
    };
};
export const preParseMdx = async (fileContent, contentDirectoryPath) => {
    try {
        fileContent = await preParseMdxHelper(fileContent, contentDirectoryPath);
    }
    catch (error) {
        fileContent = `ðŸš§ A parsing error occured. Please contact the owner of this website.`;
    }
    return fileContent;
};
const preParseMdxHelper = async (fileContent, contentDirectoryPath) => {
    const removeContentDirectoryPath = (filePath) => {
        const pathArr = createPathArr(filePath);
        const contentDirectoryPathArr = createPathArr(contentDirectoryPath);
        contentDirectoryPathArr.reverse().forEach((dir, index) => {
            if (pathArr[index] === dir) {
                pathArr.pop();
            }
        });
        return '/' + pathArr.join('/');
    };
    const removeContentDirectoryPaths = () => {
        return (tree) => {
            visit(tree, (node) => {
                if (node == null) {
                    return;
                }
                const n = node;
                if (n.name === 'img' || n.name === 'source') {
                    const srcAttrIndex = n.attributes.findIndex((attr) => (attr === null || attr === void 0 ? void 0 : attr.name) === 'src');
                    const nodeUrl = n.attributes[srcAttrIndex].value;
                    if (
                    // <img/> component
                    srcAttrIndex !== -1 &&
                        !isAbsoluteUrl(nodeUrl) &&
                        !isDataString(nodeUrl)) {
                        n.attributes[srcAttrIndex].value = removeContentDirectoryPath(nodeUrl);
                    }
                }
                else if (
                // ![]() format
                n.type === 'image' &&
                    n.url &&
                    !isAbsoluteUrl(n.url) &&
                    !isDataString(n.url)) {
                    n.url = removeContentDirectoryPath(n.url);
                }
            });
            return tree;
        };
    };
    const file = await remark()
        .use(remarkMdx)
        .use(remarkGfm)
        .use(remarkMath)
        .use(remarkFrontmatter, ['yaml', 'toml'])
        .use(removeContentDirectoryPaths)
        .process(fileContent);
    return String(file);
};
const removeLeadingSlash = (str) => {
    const path = createPathArr(str);
    return path.join('/');
};
const createPathArr = (path) => {
    return path.split('/').filter((dir) => dir !== '');
};
const isDataString = (str) => str.startsWith('data:');
const getOpenApiTitleAndDescription = (openApiFiles, openApiMetaField) => {
    if (openApiFiles == null || !openApiMetaField) {
        return {};
    }
    const { operation } = getOpenApiOperationMethodAndEndpoint(openApiFiles, openApiMetaField);
    if (operation == null) {
        return {};
    }
    return {
        title: operation.summary,
        description: operation.description,
    };
};
const getOpenApiOperationMethodAndEndpoint = (openApiFiles, openApiMetaField) => {
    const { endpoint, method, filename } = extractMethodAndEndpoint(openApiMetaField);
    let path;
    openApiFiles === null || openApiFiles === void 0 ? void 0 : openApiFiles.forEach((file) => {
        const openApiFile = file.spec;
        const openApiPath = (openApiFile === null || openApiFile === void 0 ? void 0 : openApiFile.paths) && (openApiFile === null || openApiFile === void 0 ? void 0 : openApiFile.paths[endpoint]);
        const isFilenameOrNone = !filename || filename === file.filename;
        if (openApiPath && isFilenameOrNone) {
            path = openApiPath;
        }
    });
    if (path == null) {
        return {};
    }
    let operation;
    if (method) {
        operation = path[method.toLowerCase()];
    }
    else {
        const firstOperationKey = Object.keys(path)[0];
        operation = path[firstOperationKey];
    }
    return {
        operation,
        method,
        endpoint,
    };
};
const extractMethodAndEndpoint = (openApiMetaField) => {
    const methodRegex = /(get|post|put|delete|patch)\s/i;
    const trimmed = openApiMetaField.trim();
    const foundMethod = trimmed.match(methodRegex);
    const startIndexOfMethod = foundMethod ? openApiMetaField.indexOf(foundMethod[0]) : 0;
    const endIndexOfMethod = foundMethod ? startIndexOfMethod + foundMethod[0].length - 1 : 0;
    const filename = openApiMetaField.substring(0, startIndexOfMethod).trim();
    return {
        method: foundMethod ? foundMethod[0].slice(0, -1).toUpperCase() : undefined,
        endpoint: openApiMetaField.substring(endIndexOfMethod).trim(),
        filename: filename ? filename : undefined,
    };
};

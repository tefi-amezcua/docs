import SwaggerParser from '@apidevtools/swagger-parser';
import { validateMintConfig } from '@mintlify/validation';
import { promises as _promises } from 'fs';
import fse, { outputFile } from 'fs-extra';
import path from 'path';
import { generateDecoratedMintNavigationFromPages } from '../generate.js';
import { getConfigPath, loadOpenApi } from '../utils.js';
import { getPageMetadataAndSlug, preParseMdx } from './createPage.js';
import { generateFavicons } from './generate.js';
const { readFile } = _promises;
export async function updateConfigFile(contentDirectoryPath) {
    const configTargetPath = 'src/_props/mint.json';
    const configPath = await getConfigPath(contentDirectoryPath);
    if (configPath == null) {
        throw Error('Must be run in a directory where a mint.json file exists.');
    }
    let configContents;
    try {
        configContents = await readFile(configPath, 'utf-8');
    }
    catch (err) {
        throw Error(`Unable to read mint.json: ${err}`);
    }
    let config;
    let validationResults;
    try {
        config = JSON.parse(configContents);
        validationResults = validateMintConfig(config);
    }
    catch (err) {
        throw Error(`Unable to parse mint.json: ${err}`);
    }
    if (validationResults.status === 'error') {
        throw Error(`Invalid mint.json: ${validationResults}`);
    }
    try {
        await fse.copy(configPath, configTargetPath, { overwrite: true });
    }
    catch (err) {
        throw Error(`Unable to copy mint.json: ${err}`);
    }
    return config;
}
export const updateOpenApiFiles = async (openApiFiles) => {
    const openApiTargetPath = 'src/_props/openApiFiles.json';
    await fse.remove(openApiTargetPath);
    await fse.outputFile(openApiTargetPath, JSON.stringify(openApiFiles), {
        flag: 'w',
    });
};
export const updateFiles = (contentDirectoryPath, targetDirectoryPath, filenames) => {
    const filePromises = [];
    filenames.forEach((filename) => {
        filePromises.push((async () => {
            const sourcePath = path.join(contentDirectoryPath, filename);
            const targetPath = path.join(targetDirectoryPath, filename);
            await fse.remove(targetPath);
            await fse.copy(sourcePath, targetPath);
        })());
    });
    return filePromises;
};
export const updateFavicons = async (mintConfig, contentDirectoryPath) => {
    const generatedFavicons = await generateFavicons(mintConfig, contentDirectoryPath);
    if (!generatedFavicons)
        return;
    const promises = [];
    generatedFavicons.images.forEach((img) => {
        promises.push((async () => {
            const targetPath = path.join('public', 'favicons', img.name);
            await outputFile(targetPath, Buffer.from(img.contents), {
                flag: 'w',
            });
        })());
    });
    generatedFavicons.files.forEach((file) => {
        promises.push((async () => {
            const targetPath = path.join('public', 'favicons', file.name);
            await outputFile(targetPath, file.contents, { flag: 'w' });
        })());
    });
    await Promise.all(promises);
};
export const updateGeneratedNav = async (pages, mintConfigNav) => {
    const generatedNav = generateDecoratedMintNavigationFromPages(pages, mintConfigNav);
    const targetPath = path.join('src', '_props', 'generatedNav.json');
    await outputFile(targetPath, JSON.stringify(generatedNav, null, 2), {
        flag: 'w',
    });
};
export const update = async (contentDirectoryPath, staticFilenames, openApiFiles, contentFilenames, snippets) => {
    let pagesAcc = {};
    const contentPromises = [];
    contentFilenames.forEach((filename) => {
        contentPromises.push((async () => {
            const sourcePath = path.join(contentDirectoryPath, filename);
            const targetPath = path.join('src', '_props', filename);
            const contentStr = (await readFile(sourcePath)).toString();
            const fileContent = await preParseMdx(contentStr, contentDirectoryPath);
            const { slug, pageMetadata } = getPageMetadataAndSlug(filename, contentStr, openApiFiles);
            await outputFile(targetPath, fileContent, {
                flag: 'w',
            });
            pagesAcc = Object.assign(Object.assign({}, pagesAcc), { [slug]: pageMetadata });
        })());
    });
    const initialFileUploadResponses = await Promise.all([
        updateConfigFile(contentDirectoryPath),
        ...contentPromises,
        ...updateFiles(contentDirectoryPath, 'public', staticFilenames),
        ...updateFiles(contentDirectoryPath, 'src/_props', snippets),
    ]);
    const mintConfig = initialFileUploadResponses[0];
    // Download OpenApi file if url is provided
    if (mintConfig.openapi &&
        typeof mintConfig.openapi === 'string' &&
        !mintConfig.openapi.startsWith('/') &&
        mintConfig.openapi.startsWith('http')) {
        try {
            const axios = await import('axios').then((x) => x.default);
            const { data } = await axios.get(mintConfig.openapi, {
                responseType: 'text',
                // Disable automatic JSON parsing
                transformResponse: (res) => res,
            });
            const specFromUrl = await SwaggerParser.validate(loadOpenApi(mintConfig.openapi, data));
            openApiFiles.push({
                filename: 'openapi-from-url',
                spec: specFromUrl,
            });
        }
        catch (e) {
            console.log("OpenApi file couldn't be downloaded from url.", e);
        }
    }
    await Promise.all([
        updateOpenApiFiles(openApiFiles),
        updateGeneratedNav(pagesAcc, mintConfig.navigation),
        updateFavicons(mintConfig, contentDirectoryPath),
    ]);
    return mintConfig;
};

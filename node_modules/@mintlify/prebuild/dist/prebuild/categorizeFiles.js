var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import * as path from 'path';
import { getFileList } from '../fs/index.js';
import { getFileExtension, openApiCheck } from '../utils.js';
export const categorizeFiles = async (contentDirectoryPath) => {
    var _a, e_1, _b, _c;
    const allFilesInCmdExecutionPath = getFileList(contentDirectoryPath);
    const contentFilenames = [];
    const staticFilenames = [];
    const openApiFiles = [];
    const snippets = [];
    try {
        for (var _d = true, allFilesInCmdExecutionPath_1 = __asyncValues(allFilesInCmdExecutionPath), allFilesInCmdExecutionPath_1_1; allFilesInCmdExecutionPath_1_1 = await allFilesInCmdExecutionPath_1.next(), _a = allFilesInCmdExecutionPath_1_1.done, !_a;) {
            _c = allFilesInCmdExecutionPath_1_1.value;
            _d = false;
            try {
                const filename = _c;
                const extension = getFileExtension(filename);
                let isOpenApi = false;
                switch (extension) {
                    case 'mdx':
                    case 'md':
                        if (filename.startsWith('/_snippets')) {
                            snippets.push(filename);
                            break;
                        }
                        contentFilenames.push(filename);
                        break;
                    case 'json':
                    case 'yaml':
                    case 'yml':
                        const openApiInfo = await openApiCheck(path.join(contentDirectoryPath, filename));
                        isOpenApi = openApiInfo.isOpenApi;
                        if (!isOpenApi || !openApiInfo.spec) {
                            break;
                        }
                        const fileName = path.parse(filename).base;
                        openApiFiles.push({
                            filename: fileName.substring(0, fileName.lastIndexOf('.')),
                            spec: openApiInfo.spec,
                        });
                        break;
                    default:
                        staticFilenames.push(filename);
                }
            }
            finally {
                _d = true;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (!_d && !_a && (_b = allFilesInCmdExecutionPath_1.return)) await _b.call(allFilesInCmdExecutionPath_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return { contentFilenames, staticFilenames, openApiFiles, snippets };
};
const excludedMdFiles = ['readme', 'license', 'contributing', 'contribute'];
const supportedStaticFileExtensions = [
    '.jpeg',
    '.jpg',
    '.jfif',
    '.pjpeg',
    '.pjp',
    '.png',
    '.svg',
    '.svgz',
    '.ico',
    '.webp',
    '.gif',
    '.apng',
    '.avif',
    '.bmp',
    '.mp4',
];
export const getCategory = (filePath) => {
    filePath = filePath.toLowerCase();
    const parsed = path.parse(filePath);
    if (parsed.base === 'mint.json') {
        return 'mintConfig';
    }
    const fileName = parsed.name;
    const extension = parsed.ext;
    if (filePath.startsWith('_snippets') && (extension === '.mdx' || extension === '.md')) {
        return 'snippet';
    }
    else if (extension === '.mdx') {
        return 'page';
    }
    else if (extension === '.md') {
        // Exclude common markdown files people don't want on their docs website
        if (excludedMdFiles.includes(fileName)) {
            throw new Error('Excluded Md File');
        }
        return 'page';
    }
    else if (extension === '.yaml' || extension === '.yml') {
        return 'potentialYamlOpenApiSpec';
    }
    else if (extension === '.json') {
        return 'potentialJsonOpenApiSpec';
    }
    else if (supportedStaticFileExtensions.includes(extension)) {
        return 'staticFile';
    }
    throw new Error('Unsupported File Type, No change enacted');
};
